// Copyright (c) 2023 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: liberty-deep-dive-gradle
:page-layout: guide-multipane
:page-duration: 80 minutes
:page-releasedate: 2023-04-10
:page-essential: false
:page-description: Learn how to use Liberty to develop and run Java microservices.
:page-tags: ['Jakarta EE', 'MicroProfile']
:page-related-guides: ['microprofile-openapi', 'cdi-intro', 'microprofile-config', 'jpa-intro', 'microprofile-jwt', 'microprofile-health', 'microprofile-metrics', 'containerize', 'openliberty-operator-intro', 'kubernetes-microprofile-config']
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:page-seo-title: A hands-on technical deep dive on Liberty
:page-seo-description: An in-depth and end-to-end tutorial with examples (akin to a "masterclass") on how to easily develop cloud-native Java applications and microservices using Jakarta EE and MicroProfile APIs using Open Liberty and WebSphere Liberty as the runtime or framework, and how to build, run and deploy the applications in containers to Kubernetes.
:guide-author: Open Liberty
= A Technical Deep Dive on Liberty

[.hidden]
NOTE: This repository contains the documentation source. To view this exercise in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Liberty is a cloud-optimized Java runtime that is fast to start up with a low memory footprint and a development mode, known as dev mode, for quick iteration. With Liberty, adopting the latest open cloud-native Java APIs, like MicroProfile and Jakarta EE, is as simple as adding features to your server configuration. The Liberty zero migration architecture lets you focus on what's important and not the APIs changing under you.

== What you'll learn

You will learn how to build a RESTful microservice on Liberty with Jakarta EE and MicroProfile. You will use Gradle throughout this exercise to build the microservice and to interact with the running Liberty instance. Then, you’ll build a container image for the microservice. You will also learn how to secure the REST endpoints and use JSON Web Tokens to communicate with the provided `system` secured microservice.

The microservice that you’ll work with is called `inventory`. The `inventory` microservice persists data into a PostgreSQL database. 

image::inventory.png[Inventory microservice,align="center"]

== Additional prerequisites

Before you begin, Podman needs to be installed. For installation instructions, refer to the https://podman.io/getting-started/installation[official Podman documentation^]. You will build and run the microservices in containers.

If you are running Mac or Windows, make sure to start your Podman-managed VM before you proceed.


== Getting started

ifdef::cloud-hosted[]
To open a new command-line session,
select **Terminal** > **New Terminal** from the menu of the IDE.

Run the following command to navigate to the **/home/project** directory:

```bash
cd /home/project
```
endif::[]

Clone the https://github.com/OpenLiberty/guide-liberty-deep-dive.git[Git repository^]:

[role='command']
```
git clone https://github.com/openliberty/guide-liberty-deep-dive.git
cd guide-liberty-deep-dive
```

The `start` directory is an empty directory where you will build the `inventory` service.

The `finish` directory contains the finished projects of different modules that you will build.

ifndef::cloud-hosted[]
Before you begin, make sure you have all the necessary prerequisites.
endif::[]

ifdef::cloud-hosted[]
In this IBM Cloud environment, you need to change the user home to ***/home/project*** by running the following command:
```bash
sudo usermod -d /home/project theia
```
endif::[]

== Getting started with Liberty and REST

Liberty now offers an easier way to get started with developing your application: the Open Liberty Starter. This tool provides a simple and quick way to get the necessary files to start building an application on Liberty. Through this tool, you can specify your application and project name. You can also choose a build tool from either Maven or Gradle, and pick the Java SE, Jakarta EE, and MicroProfile versions for your application.

In this workshop, the starting project is provided for you or you can use the Open Liberty Starter to create the starting point of the application. Gradle is used as the selected build tool and the application uses of Jakarta EE 9.1 and MicroProfile 5.

To get started with this tool, see the Getting Started page: https://openliberty.io/start/[https://openliberty.io/start/^]

On that page, enter the following properties in the **Create a starter application** wizard.

* Under Group specify: `io.openliberty.deepdive`
* Under Artifact specify: `inventory`
* Under Build Tool select: `Gradle`
* Under Java SE Version select: `your version`
* Under Java EE/Jakarta EE Version select: `9.1`
* Under MicroProfile Version select: `5` 

ifndef::cloud-hosted[]
Then, click `Generate Project`, which downloads the starter project as `inventory.zip` file to the `start` directory of this project. You can replace the provided `inventory.zip` file.

Next, extract the `inventory.zip` file to the `guide-liberty-deepdive-gradle/start/inventory` directory.

[role='command']
```
cd start
unzip inventory.zip -d inventory
```
endif::[]

ifdef::cloud-hosted[]
In this Skills Network environment, instead of manually downloading and extracting the project, run the following commands:
```bash
cd /home/project/guide-liberty-deep-dive/start
curl -o inventory.zip 'https://start.openliberty.io/api/start?a=inventory&b=maven&e=9.1&g=io.openliberty.deepdive&j=11&m=5.0'
unzip inventory.zip -d inventory
```

After getting the ***inventory*** project, switch the workspace to the ***/home/project/guide-liberty-deep-dive/start/inventory*** directory.
> - Select **File** > **Close Workspace** from the menu of the IDE.
>   - Click the OK button to confirm to close.
>   - Wait for the IDE to refresh.
> - Select **File** > **Open Workspace...** from the menu of the IDE.
>   - In the **Open Workspace** window, select the ***/home/project/guide-liberty-deep-dive/start/inventory*** directory and click the **Open** button.
>   - Wait for the IDE to refresh.
endif::[]

=== Building the application

This application is configured to be built with Gradle. Every Gradle-configured project contains a `settings.gradle` and a `build.gradle` file that defines the project configuration, dependencies, and plug-ins.

// file 0
settings.gradle
[source, gradle, linenums, role='code_column']
----
include::finish/module-getting-started/settings.gradle[]
----

// file 1
build.gradle
[source, gradle, linenums, role='code_column']
----
include::finish/module-getting-started/build.gradle[]
----

Your [hotspot file=0]`settings.gradle` and [hotspot file=1]`build.gradle` files are located in the `start/inventory` directory and is configured to include the [hotspot=libertyGradlePlugin file=1]`io.openliberty.tools.gradle.Liberty` Liberty Gradle plugin. Using the plug-in, you can install applications into Liberty and manage the server instances.

To begin, open a command-line session and navigate to your application directory. 

ifndef::cloud-hosted[]
[role='command']
```
cd inventory
```
endif::[]

ifdef::cloud-hosted[]
```bash
cd /home/project/guide-liberty-deep-dive/start/inventory
```
endif::[]

Build and deploy the `inventory` microservice to Liberty by running the Gradle `libertyRun` task:

[role='command']
```
./gradlew libertyRun
```

The `gradlew` command initiates a Gradle build, during which the target directory is created to store all build-related files.

The `libertyRun` argument specifies the Liberty `run` task, which starts a Liberty server instance in the foreground. As part of this phase, a Liberty server runtime is downloaded and installed into the `build/wlp` directory. Additionally, a server instance is created and configured in the `build/wlp/usr/servers/defaultServer` directory, and the application is installed into that server by using https://www.ibm.com/support/knowledgecenter/en/SSEQTP_liberty/com.ibm.websphere.wlp.doc/ae/rwlp_loose_applications.html[loose config^].

For more information about the Liberty Gradle plug-in, see its https://github.com/OpenLiberty/ci.gradle[GitHub repository^].

While the server starts up, various messages display in your command-line session. Wait for the following message, which indicates that the server startup is complete:

[source, role="no_copy"]
----
[INFO] [AUDIT] CWWKF0011I: The server defaultServer is ready to run a smarter planet.
----

When you need to stop the server, press `CTRL+C` in the command-line session where you ran the server, or run the `libertyStop` goal from the `start/inventory` directory in another command-line session:

[role='command']
```
./gradlew libertyStop
```


=== Starting and stopping the Liberty server in the background

Although you can start and stop the server in the foreground by using the Gradle `libertyRun` task, you can also start and stop the server in the background with the Gradle `libertyStart` and `libertyStop` goals:

[role='command']
----
./gradlew libertyStart
./gradlew libertyStop
----


=== Updating the server configuration without restarting the server

The Liberty Gradle plug-in includes a `dev` task that listens for any changes in the project, including application source code or configuration. The Liberty server automatically reloads the configuration without restarting. This goal allows for quicker turnarounds and an improved developer experience.

If the Liberty server is running, stop it and restart it in dev mode by running the `libertyDev` goal in the `start/inventory` directory:

[role='command']
```
./gradlew libertyDev
```

After you see the following message, your application server in dev mode is ready:

[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
----

Dev mode automatically picks up changes that you make to your application and allows you to run tests by pressing the `enter/return` key in the active command-line session. When you’re working on your application, rather than rerunning Gradle tasks, press the `enter/return` key to verify your change.

=== Developing a RESTful microservice

Now that a basic Liberty application is running, the next step is to create the additional application and resource classes that the application needs. Within these classes, you use Jakarta REST and other MicroProfile and Jakarta APIs.

ifdef::cloud-hosted[]
Open another command-line session by selecting **Terminal** > **New Terminal** from the menu of the IDE. Go to the ***start/inventory*** directory.
```bash
cd /home/project/guide-liberty-deep-dive/start/inventory
```
endif::[]

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `Inventory` class.#
`src/main/java/io/openliberty/deepdive/rest/Inventory.java`
----

Inventory.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/Inventory.java[]
----

This `Inventory` class stores a record of all systems and their system properties. The [hotspot=getSystem file=0]`getSystem()` method within this class retrieves and returns the system data from the system. The [hotspot=add file=0]`add()` method enables the addition of a system and its data to the inventory. The [hotspot=update file=0]`update()` method enables a system and its data on the inventory to be updated. The [hotspot=removeSystem file=0]`removeSystem()` method enables the deletion of a system from the inventory.


Create the `model` subdirectory, then create the `SystemData` class. The `SystemData` class is a Plain Old Java Object (POJO) that represents a single inventory entry. 

ifndef::cloud-hosted[]
[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\java\io\openliberty\deepdive\rest\model
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir src/main/java/io/openliberty/deepdive/rest/model
```
--
endif::[]

ifdef::cloud-hosted[]
```bash
mkdir /home/project/guide-liberty-deep-dive/start/inventory/src/main/java/io/openliberty/deepdive/rest/model
```
endif::[]

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `SystemData` class.#
`src/main/java/io/openliberty/deepdive/rest/model/SystemData.java`
----

SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

The `SystemData` class contains the hostname, operating system name, Java version, and heap size properties. The various methods within this class allow the viewing or editing the properties of each system in the inventory.


[role="code_command hotspot file=2", subs="quotes"]
----
#Create the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-getting-started/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

In Jakarta RESTful Web Services, a single class like the `SystemResource.java` class must represent a single resource, or a group of resources of the same type. In this application, a resource might be a system property, or a set of system properties. It is efficient to have a single class handle multiple different resources, but keeping a clean separation between types of resources helps with maintainability.

The [hotspot=path file=2]`@Path` annotation on this class indicates that this resource responds to the `/systems` path in the RESTful application. The [hotspot=applicationPath file=2]`@ApplicationPath` annotation in the `RestApplication` class, together with the [hotspot=path file=2]`@Path` annotation in the `SystemResource` class, indicates that this resource is available at the `/api/systems` path.

The Jakarta RESTful Web Services API maps the HTTP methods on the URL to the methods of the class by using annotations. This application uses the `GET` annotation to map an HTTP `GET` request to the `/api/systems` path.

The [hotspot=getListContents file=2]`@GET` annotation on the `listContents` method indicates that the method is to be called for the HTTP `GET` method. The [hotspot=producesListContents file=2]`@Produces` annotation indicates the format of the content that is returned. The value of the [hotspot=producesListContents file=2]`@Produces` annotation is specified in the HTTP `Content-Type` response header. For this application, a JSON structure is returned for these `Get` methods. The `Content-Type` for a JSON response is `application/json` with `MediaType.APPLICATION_JSON` instead of the `String` content type. Using a constant such as `MediaType.APPLICATION_JSON` is better as in case of a spelling error, a compile failure occurs.

The Jakarta RESTful Web Services API supports a number of ways to marshal JSON. The Jakarta RESTful Web Services specification mandates JSON-Binding (JSON-B). The method body returns the result of [hotspot=getSystems file=2]`inventory.getSystems()`. Because the method is annotated with [hotspot=producesListContents file=2]`@Produces(MediaType.APPLICATION_JSON)`, the Jakarta RESTful Web Services API uses JSON-B to automatically convert the returned object to JSON data in the HTTP response.


=== Running the application

Because you started the Liberty server in dev mode at the beginning of this exercise, all the changes were automatically picked up.

Check out the service that you created at the http://localhost:9080/inventory/api/systems URL. If successful, it returns `[]` to you.

ifdef::cloud-hosted[]
Open another command-line session by selecting **Terminal** > **New Terminal** from the menu of the IDE, and run the following curl command:
```bash
curl 'http://localhost:9080/inventory/api/systems'
```

You can expect to see the following output:

```
[]
```
endif::[]


== Documenting APIs

Next, you will investigate how to document and filter RESTful APIs from annotations, POJOs, and static OpenAPI files by using MicroProfile OpenAPI.

The OpenAPI specification, previously known as the Swagger specification, defines a standard interface for documenting and exposing RESTful APIs. This specification allows both humans and computers to understand or process the functionalities of services without requiring direct access to underlying source code or documentation. The MicroProfile OpenAPI specification provides a set of Java interfaces and programming models that allow Java developers to natively produce OpenAPI v3 documents from their RESTful applications.

build.gradle
[source, gradle, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/build.gradle[]
----

server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/src/main/liberty/config/server.xml[]
----

The MicroProfile OpenAPI API is included in the [hotspot=mp5 file=0]`microProfile` dependency that is specified in your `build.gradle` file. The [hotspot=mp5 file=1]`microProfile` feature that includes the `mpOpenAPI` feature is also enabled in the `server.xml` file.

=== Generating the OpenAPI document

Because the Jakarta RESTful Web Services framework handles basic API generation for Jakarta RESTful Web Services annotations, a skeleton OpenAPI tree can be generated from the existing inventory service. You can use this tree as a starting point and augment it with annotations and code to produce a complete OpenAPI document.

To see the generated OpenAPI tree, you can either visit the http://localhost:9080/openapi URL or visit the http://localhost:9080/openapi/ui URL for a more interactive view of the APIs. Click the `interactive UI` link on the welcome page. Within this UI, you can view each of the endpoints that are available in your application and any schemas. Each endpoint is color coordinated to easily identify the type of each request (for example GET, POST, PUT, DELETE, etc.). Clicking each endpoint within this UI enables you to view further details of each endpoint's parameters and responses. This UI is used for the remainder of this workshop to view and test the application endpoints.


=== Augmenting the existing Jakarta RESTful Web Services annotations with OpenAPI annotations

Because all Jakarta RESTful Web Services annotations are processed by default, you can augment the existing code with OpenAPI annotations without needing to rewrite portions of the OpenAPI document that are already covered by the Jakarta RESTful Web Services framework.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemResources` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----


Add OpenAPI [hotspot=listContentsAPIResponseSchema hotspot=getSystemAPIResponseSchema file=0]`@APIResponseSchema`, [hotspot=addSystemAPIResponses file=0]`@APIResponses`, [hotspot=addSystemAPIResponse file=0]`@APIResponse`, [hotspot=addSystemParameters file=0]`@Parameters`, [hotspot=addSystemParameter file=0]`@Parameter`, and [hotspot=addSystemOperation file=0]`@Operation` annotations to the REST methods, [hotspot=listContents file=0]`listContents()`, [hotspot=getSystem file=0]`getSystem()`, [hotspot=addSystem file=0]`addSystem()`, [hotspot=updateSystem file=0]`updateSystem()`, [hotspot=removeSystem file=0]`removeSystem()`, and [hotspot=addSystemClient file=0]`addSystemClient()`.

Note, the `@Parameter` annotation can be placed either [hotspot=getSystemParameter file=0]`inline` or [hotspot=removeSystemParameter file=0]`outline`. Examples of both are provided within this workshop.

Many OpenAPI annotations are available and can be used according to what's best for your application and its classes. You can find all the annotations in the https://download.eclipse.org/microprofile/microprofile-open-api-3.0/microprofile-openapi-spec-3.0.html#_annotations[MicroProfile OpenAPI specification^].

Because the Liberty server was started in dev mode at the beginning of this exercise, your changes were automatically picked up. Go to the http://localhost:9080/openapi URL to see the updated endpoint descriptions. The endpoints at which your REST methods are served now more meaningful:

ifdef::cloud-hosted[]
```bash
curl http://localhost:9080/openapi
```
endif::[]

[source, YAML, role="no_copy"]
----
---
openapi: 3.0.3
info:
  title: Generated API
  version: "1.0"
servers:
- url: http://localhost:9080/inventory
- url: https://localhost:9443/inventory
paths:
  /api/systems:
    get:
      summary: List contents.
      description: Returns the currently stored host:properties pairs in the inventory.
      operationId: listContents
      responses:
        "200":
          description: Returns the currently stored host:properties pairs in the inventory.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SystemData'
...
----

You can also visit the http://localhost:9080/openapi/ui URL to see each endpoint's updated description. Click each of the icons within the UI to see the updated descriptions for each of the endpoints.
ifdef::cloud-hosted[]
In this Skills Network environment, simply click the following button:

::startApplication{port="9080" display="external" name="Visit OpenAPI UI" route="/openapi/ui"}
endif::[]

=== Augmenting POJOs with OpenAPI annotations

OpenAPI annotations can also be added to POJOs to describe what they represent. Currently, the OpenAPI document doesn't have a meaningful description of the `SystemData` POJO so it's difficult to tell exactly what this POJO is used for. To describe the `SystemData` POJO in more detail, augment the `SystemData.java` file with some OpenAPI annotations.

[role='code_command hotspot', subs="quotes"]
----
#Replace the `SystemData` class.#
`src/main/java/io/openliberty/deepdive/rest/model/SystemData.java`
----

SystemData.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-openapi/src/main/java/io/openliberty/deepdive/rest/model/SystemData.java[]
----

Add OpenAPI `@Schema` annotations to the [hotspot=SystemDataSchema]`SystemData` class and the [hotspot=hostnameSchema]`hostname` variable.


Refresh the http://localhost:9080/openapi URL to see the updated OpenAPI tree. You should see much more meaningful data for the Schema:

ifdef::cloud-hosted[]
```bash
curl http://localhost:9080/openapi
```
endif::[]

[source, YAML, role="no_copy"]
----
components:
  schemas:
    SystemData:
      description: POJO that represents a single inventory entry.
      required:
      - hostname
      - properties
      type: object
      properties:
        hostname:
          type: string
        properties:
          type: object
----

Again, you can also view this at the http://localhost:9080/openapi/ui URL. Scroll down in the UI to the schemas section and open up the SystemData schema icon.

ifdef::cloud-hosted[]
::startApplication{port="9080" display="external" name="Visit OpenAPI UI" route="/openapi/ui"}
endif::[]

You can also use this UI to try out the various endpoints. In the UI, head to the POST request `/api/systems`. This endpoint enables you to create a system. Once you've opened this icon up, click the `Try it out` button. Now enter appropriate values for each of the required parameters and click the `Execute` button.

You can verify that this system was created by testing the `/api/systems` GET request that returns the currently stored system data in the inventory. Execute this request in the UI, then in the response body you should see your system and its data listed.

You can follow these same steps for updating and deleting systems: visiting the corresponding endpoint in the UI, executing the endpoint, and then verifying the result by using the `/api/systems` GET request endpoint.

You can learn more about MicroProfile OpenAPI from the https://openliberty.io/guides/microprofile-openapi.html[Documenting RESTful APIs guide^].


==  Configuring the microservice

Next, you can externalize your Liberty server configuration and inject configuration for your microservice by using MicroProfile Config.


=== Enabling configurable ports and context root

So far, you used hardcoded values to set the HTTP and HTTPS ports and the context root for the Liberty server. These configurations can be externalized so you can easily change their values when you want to deploy your microservice by different ports and context root.

[role='code_command hotspot file=0', subs="quotes"]
----
#Replace the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/src/main/liberty/config/server.xml[]
----

Add variables for the [hotspot=httpPortVariable file=0]`HTTP` port, [hotspot=httpsPortVariable file=0]`HTTPS` port, and the [hotspot=contextRootVariable file=0]`context root` to the `server.xml` file. Change the [hotspot=editedHttpEndpoint file=0]`httpEndpoint` element to reflect the new `default.http.port` and `default.http.port` variables and change the [hotspot=editedContextRoot file=0]`contextRoot` to use the new `default.context.root` variable too.

[role='code_command hotspot file=1', subs="quotes"]
----
#Replace the `build.gradle` file.#
`build.gradle`
----

build.gradle
[source, xml, gradle, role='code_column']
----
include::finish/module-config/build.gradle[]
----

Add properties for the [hotspot=httpPort file=1]`HTTP` port, [hotspot=httpsPort file=1]`HTTPS` port, and the [hotspot=contextRoot file=1]`context root` to the `build.gradle` file. 

You can try changing the value of these variables in the `build.gradle` file:

* update [hotspot=httpPort file=1]`liberty.server.var.'default.http.port'` to `9081`
* update [hotspot=httpsPort file=1]`liberty.server.var.'default.https.port'` to `9445`
* update [hotspot=contextRoot file=1]`liberty.server.var.'default.context.root'` to `/trial`

Because you are using dev mode, these changes are automatically picked up by the server. After you see the following message, your application server in dev mode is ready again:

[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
----

ifndef::cloud-hosted[]
Now, you can access the application by the http://localhost:9081/trial/api/systems URL. Alternatively, for the updated OpenAPI UI, use the following URL http://localhost:9081/openapi/ui/.
endif::[]

ifdef::cloud-hosted[]
Now, you can access the application by running the following command:
```bash
curl http://localhost:9081/trial/api/systems
```

Alternatively, for the updated OpenAPI UI, click the following button to visit ***/openapi/ui*** endpoint:

::startApplication{port="9081" display="external" name="Visit OpenAPI UI" route="/openapi/ui"}
endif::[]

When you are finished trying out changing this configuration, change the variables back to their original values.

* update [hotspot=httpPort file=1]`liberty.server.var.'default.http.port'` to `9080`
* update [hotspot=httpsPort file=1]`liberty.server.var.'default.https.port'` to `9443`
* update [hotspot=contextRoot file=1]`liberty.server.var.'default.context.root'` to `/inventory`

Wait until you see the following message:

[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
----

=== Injecting static configuration

You can now explore how to use MicroProfile's Config API to inject static configuration into your microservice.

The MicroProfile Config API is included in the MicroProfile dependency that is specified in your `build.gradle` file. Look for the dependency with the `microprofile` artifact ID. This dependency provides a library that allows the use of the MicroProfile Config API. The `microProfile` feature is also enabled in the `server.xml` file.


First, you need to edit the `SystemResource` class to inject static configuration into the `CLIENT_PORT` variable.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

SystemResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

The [hotspot=inject file=0]`@Inject` annotation injects the value from other configuration sources to the `CLIENT_PORT` variable. The [hotspot=configProperty file=0]`@ConfigProperty` defines the external property name as `client.https.port`.

Update the [hotspot=printClientPort file=0]`POST` request so that the `/client/{hostname}` endpoint prints the `CLIENT_PORT` value.


=== Adding the microprofile-config.properties file

Define the configurable variables in the `microprofile-config.properties` configuration file for MicroProfile Config at the `src/main/resources/META-INF` directory.

ifndef::cloud-hosted[]
[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\resources\META-INF
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir -p src/main/resources/META-INF
```
--
endif::[]

ifdef::cloud-hosted[]
```bash
mkdir -p /home/project/guide-liberty-deep-dive/start/inventory/src/main/resources/META-INF
```
endif::[]

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `microprofile-config.properties` file.#
`src/main/resources/META-INF/microprofile-config.properties`
----

microprofile-config.properties
[source, text, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-config/src/main/resources/META-INF/microprofile-config.properties[]
----

Using the [hotspot=ordinal file=0]`config_ordinal` variable in this properties file, you can set the ordinal of this file and thus other configuration sources.

The [hotspot=configPort file=0]`client.https.port` variable enables the client port to be overwritten.

Revisit the OpenAPI UI http://localhost:9080/openapi/ui to view these changes. Open the `/api/systems/client/{hostname}` endpoint and run it within the UI to view the `CLIENT_PORT` value.

ifdef::cloud-hosted[]
::startApplication{port="9080" display="external" name="Visit OpenAPI UI" route="/openapi/ui"}
endif::[]

You can learn more about MicroProfile Config from the https://openliberty.io/guides/microprofile-config.html[Configuring microservices guide^].



== Securing RESTful APIs

Now you can secure your RESTful APIs. Navigate to your application directory. 

ifndef::cloud-hosted[]
[role='command']
```
cd start/inventory
```
endif::[]

ifdef::cloud-hosted[]
```bash
cd /home/project/guide-liberty-deep-dive/start/inventory
```
endif::[]

Begin by adding some users and user groups to your `server.xml` Liberty configuration file.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

// File 0
server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-securing/src/main/liberty/config/server.xml[]
----

The [hotspot=basicregistry file=0]`basicRegistry` element contains a list of all users for the application and their passwords, as well as all of the user groups. Note that this [hotspot=basicregistry file=0]`basicRegistry` element is a very simple case for learning purposes. For more information about the different user registries, see the https://openliberty.io/docs/latest/user-registries-application-security.html[User registries documentation^]. The [hotspot=myadmins file=0]`admin` group tells the application which of the users are in the administrator group. The [hotspot=myusers file=0]`user` group tells the application that users are in the user group.

The `security-role` maps the [hotspot=adminrole file=0]`admin` role to the [hotspot=myadmins file=0]`admin` group, meaning that all users in the `admin` group have the administrator role. Similarly, the [hotspot=userrole file=0]`user` role is mapped to the [hotspot=myusers file=0]`user` group, meaning all users in the `user` group have the user role.

Your application has the following users and passwords:

[cols="<35, ^200, ^200"]
|===
| *Username* | *Password* | *Role*
| bob | bobpwd | admin, user
| alice | alicepwd | user
|===

Now you can secure the `inventory` service.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

// File 1
SystemResource.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-securing/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

This class now has role-based access control. The role names that are used in the [hotspot=putRolesAllowed hotspot=deleteRolesAllowed file=1]`@RolesAllowed` annotations are mapped to group names in the groups claim of the JSON Web Token (JWT). This mapping results in an authorization decision wherever the security constraint is applied.

The [hotspot=putEndpoint file=1]`/{hostname}` endpoint that is annotated with the [hotspot=put file=1]`@PUT` annotation updates a system in the inventory. This PUT endpoint is annotated with the [hotspot=putRolesAllowed file=1]`@RolesAllowed({ "admin", "user" })` annotation. Only authenticated users with the role of `admin` or `user` can access this endpoint.

The [hotspot=deleteEndpoint file=1]`/{hostname}` endpoint that is annotated with the [hotspot=delete file=1]`@DELETE` annotation removes a system from the inventory. This DELETE endpoint is annotated with the [hotspot=deleteRolesAllowed file=1]`@RolesAllowed({ "admin" })` annotation. Only authenticated users with the role of `admin` can access this endpoint.

You can manually check that the `inventory` microservice is secured by making requests to the PUT and DELETE endpoints.

Before making requests, you must add a system to the inventory. Try adding a system by using the POST endpoint `/systems` by running the following command:

[role='command']
----
curl -X POST 'http://localhost:9080/inventory/api/systems?hostname=localhost&osName=mac&javaVersion=11&heapSize=1'
----

You can expect the following response:

[source, role="no_copy"]
----
{ "ok" : "localhost was added." }
----

This command calls the `/systems` endpoint and adds a system `localhost` to the inventory. You can validate that the command worked by calling the `/systems` endpoint with a `GET` request to retrieve all the systems in the inventory, with the following curl command:

ifndef::cloud-hosted[]
[role='command']
----
curl -s 'http://localhost:9080/inventory/api/systems'
----
endif::[]

ifdef::cloud-hosted[]
```bash
curl -s 'http://localhost:9080/inventory/api/systems' | jq
```
endif::[]

You can now expect the following response:

[source, role=no_copy]
----
[{"heapSize":1,"hostname":"localhost","javaVersion":"11","osName":"mac","id":23}]
----

Now try calling your secure PUT endpoint to update the system that you just added by the following curl command:

[role='command']
----
curl -k --user alice:alicepwd -X PUT 'http://localhost:9080/inventory/api/systems/localhost?heapSize=2097152&javaVersion=11&osName=linux'
----

As this endpoint is accessible to the groups `user` and `admin`, you must log in with `user` credentials to update the system.

You should see the following response:

[source, role=no_copy]
----
{ "ok" : "localhost was updated." }
----

This response means that you logged in successfully as an authenticated `user`, and that the endpoint works as expected.

Now try calling the DELETE endpoint. As this endpoint is only accessible to `admin` users, you can expect this command to fail if you attempt to access it with a user in the `user` group.

You can check that your application is secured against these requests with the following command:

[role='command']
----
curl -k --user alice:alicepwd -X DELETE 'https://localhost:9443/inventory/api/systems/localhost'
----

As `alice` is part of the `user` group, this request cannot work. In your dev mode console, you can expect the following output:

[source, role=no_copy]
----
jakarta.ws.rs.ForbiddenException: Unauthorized
----

Now attempt to call this endpoint with an authenticated `admin` user that can work correctly. Run the following curl command:

[role='command']
----
curl -k --user bob:bobpwd -X DELETE 'https://localhost:9443/inventory/api/systems/localhost'
----

You can expect to see the following response:

[source, role=no_copy]
----
{ "ok" : "localhost was removed." }
----

This response means that your endpoint is secure. Validate that it works correctly by calling the `/systems` endpoint with the following curl command:

[role='command']
----
curl 'http://localhost:9080/inventory/api/systems'
----

You can expect to see the following output:

[source, role=no_copy]
----
[]
----

This response shows that the endpoints work as expected and that the system you added was successfully deleted.

== Consuming the secured RESTful APIs by JWT

You can now implement JSON Web Tokens (JWT) and configure them as Single Sign On (SSO) cookies to use the RESTful APIs. The JWT that is generated by Liberty is used to communicate securely between the `inventory` and `system` microservices. You can implement the `/client/{hostname}` POST endpoint to collect the properties from the `system` microservices and create a system in the inventory. 

The `system` microservice is provided for you.

=== Writing the RESTful client interface
Create the `client` subdirectory. Then, create a RESTful client interface for the `system` microservice in the `inventory` microservice.

ifndef::cloud-hosted[]
[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\java\io\openliberty\deepdive\rest\client
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir src/main/java/io/openliberty/deepdive/rest/client
```
--
endif::[]

ifdef::cloud-hosted[]
```bash
mkdir /home/project/guide-liberty-deep-dive/start/inventory/src/main/java/io/openliberty/deepdive/rest/client
```
endif::[]

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `SystemClient` interface.#
`src/main/java/io/openliberty/deepdive/rest/client/SystemClient.java`
----

// File 0
SystemClient.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/java/io/openliberty/deepdive/rest/client/SystemClient.java[]
----


This interface declares methods for accessing each of the endpoints that are set up for you in the `system` service. The MicroProfile Rest Client feature automatically builds and generates a client implementation based on what is defined in the [hotspot file=0]`SystemClient` interface. You don’t need to set up the client and connect with the remote service.

Now create the required exception classes that are used by the `SystemClient` instance.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `UnknownUriException` class.#
`src/main/java/io/openliberty/deepdive/rest/client/UnknownUriException.java`
----

// File 1
UnknownUriException.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/java/io/openliberty/deepdive/rest/client/UnknownUriException.java[]
----

This class is an exception that is thrown when an unknown URI is passed to the `SystemClient`.

[role="code_command hotspot file=2", subs="quotes"]
----
#Create the `UnknownUriExceptionMapper` class.#
`src/main/java/io/openliberty/deepdive/rest/client/UnknownUriExceptionMapper.java`
----

// File 2
UnknownUriExceptionMapper.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/java/io/openliberty/deepdive/rest/client/UnknownUriExceptionMapper.java[]
----

This class links the `UnknownUriException` class with the corresponding response code through a `ResponseExceptionMapper` mapper class.

=== Implementing the `/client/{hostname}` endpoint

Now implement the `/client/{hostname}` POST endpoint of the `SystemResource` class to consume the secured `system` microservice.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

// File 0
SystemResource.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

The [hotspot=getSystemClient file=0]`getSystemClient()` method builds and returns a new instance of the `SystemClient` class for the hostname provided. The [hotspot=addSystemClient file=0]`/client/{hostname}` POST endpoint uses this method to create a REST client that is called [hotspot=getCustomRestClient file=0]`customRestClient` to consume the `system` microservice.

A JWT instance is injected to the [hotspot=jwt file=0]`jwt` field variable by the `jwtSso` feature. It is used to create the [hotspot=authHeader file=0]`authHeader` authentication header. It is then passed as a parameter to the endpoints of the [hotspot=customRestClient file=0]`customRestClient` to get the properties from the `system` microservice. A [hotspot=addSystem file=0]`system` is then added to the inventory.

=== Configuring the JSON Web Token

Next, add the JSON Web Token (Single Sign On) feature to the server configuration file for the `inventory` service.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

// File 0
server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-jwt/src/main/liberty/config/server.xml[]
----

// File 1
microprofile-config.properties
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/system/src/main/webapp/META-INF/microprofile-config.properties[]
----

The [hotspot=jwtSsoFeature file=0]`jwtSso` feature adds the libraries that are required for JWT SSO implementation. Configure the [hotspot=jwtSsoConfig file=0]`jwtSso` feature by adding the [hotspot=jwtBuilder file=0]`jwtBuilder` configuration to your `server.xml`. Also, configure the MicroProfile [hotspot=mpJwt file=0]`JWT` with the `audiences` and `issuer` properties that match the [hotspot file=1]`microprofile-config.properties` defined at the `system/src/main/webapp/META-INF` directory under the `system` project. For more information, see the https://www.openliberty.io/docs/latest/reference/feature/jwtSso-1.0.html[JSON Web Token Single Sign-On feature^], https://www.openliberty.io/docs/latest/reference/config/jwtSso.html[jwtSso element^], and https://www.openliberty.io/docs/latest/reference/config/jwtBuilder.html[jwtBuilder element^] documentation.

The [hotspot=keyStore file=0]`keyStore` element is used to define the repository of security certificates used for SSL encryption. The `id` attribute is a unique configuration ID that is set to `defaultKeyStore`. The `password` attribute is used to load the keystore file, and its value can be stored in clear text or encoded form. To learn more about other attributes, see the https://openliberty.io/docs/latest/reference/config/keyStore.html#keyStore.html[keyStore^] attribute documentation. 

Because the keystore file is not provided at the `src` directory, Liberty creates a Public Key Cryptography Standards #12 (PKCS12) keystore file for you by default. This file needs to be replaced, as the [hotspot=keyStore file=0]`keyStore` configuration must be the same in both `system` and `inventory` microservices. As the configured `system` microservice is already provided for you, copy the `key.p12` keystore file from the `system` microservice to your `inventory` service.

ifndef::cloud-hosted[]
[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\liberty\config\resources\security
copy ..\..\finish\system\src\main\liberty\config\resources\security\key.p12 src\main\liberty\config\resources\security\key.p12
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir -p src/main/liberty/config/resources/security
cp ../../finish/system/src/main/liberty/config/resources/security/key.p12 src/main/liberty/config/resources/security/key.p12
```
--
endif::[]

ifdef::cloud-hosted[]
```bash
mkdir -p /home/project/guide-liberty-deep-dive/start/inventory/src/main/liberty/config/resources/security
cp /home/project/guide-liberty-deep-dive/finish/system/src/main/liberty/config/resources/security/key.p12 \
   /home/project/guide-liberty-deep-dive/start/inventory/src/main/liberty/config/resources/security/key.p12
```
endif::[]

Now configure the client https port in the `build.gradle` configuration file.

[role="code_command hotspot file=2", subs="quotes"]
----
#Replace the `build.gradle` file.#
`build.gradle`
----

// File 2
build.gradle
[source, gradle, linenums, role='code_column']
----
include::finish/module-jwt/build.gradle[]
----

Configure the client https port by setting the [hotspot=https file=2]`liberty.server.var.'client.https.port'` to `9444`.

In your dev mode console for the `inventory` microservice, press `CTRL+C` to stop the server. Then, restart the dev mode of the `inventory` microservice.
[role='command']
```
./gradlew libertyDev
```

After you see the following message, your application server in dev mode is ready again:

[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
----

=== Running the `/client/{hostname}` endpoint

Open another command-line session and run the `system` microservice from the `finish` directory.

ifndef::cloud-hosted[]
[role='command']
----
cd finish/system
./gradlew libertyRun
----
endif::[]

ifdef::cloud-hosted[]
```bash
cd /home/project/guide-liberty-deep-dive/finish/system
mvn liberty:run
```
endif::[]

Wait until the following message displays on the `system` microservice console.
[source]
----
CWWKF0011I: The defaultServer server is ready to run a smarter planet. ...
----

You can check that the `system` microservice is secured against unauthenticated requests at the https://localhost:9444/system/api/heapsize URL. You can expect to see the following error in the console of the `system` microservice:

ifdef::cloud-hosted[]
Open another command-line session and run the following command:
```bash
curl -k 'https://localhost:9444/system/api/heapsize'
```
endif::[]

[source]
----
CWWKS5522E: The MicroProfile JWT feature cannot perform authentication because a MicroProfile JWT cannot be found in the request.
----

You can check that the `/client/{hostname}` endpoint you updated can access the `system` microservice. 

Make an authorized request to the new `/client/{hostname}` endpoint.
As this endpoint is restricted to `admin`, you can use the login credentials for `bob`, which is in the `admin` group.

[role='command']
----
curl -k --user bob:bobpwd -X POST 'https://localhost:9443/inventory/api/systems/client/localhost'
----

You can expect the following output:

[source, role='no_copy']
----
{ "ok" : "localhost was added." }
----

You can verify that this endpoint works as expected by running the following command:

ifndef::cloud-hosted[]
[role='command']
----
curl 'http://localhost:9080/inventory/api/systems'
----
endif::[]

ifdef::cloud-hosted[]
```bash
curl -s 'http://localhost:9080/inventory/api/systems' | jq
```
endif::[]

You can expect to see your system listed in the output.

[source]
----
[
  {
    "heapSize": 2999975936,
    "hostname": "localhost",
    "id": 11,
    "javaVersion": "11.0.11",
    "osName": "Linux"
  }
]
----

== Adding health checks
Next, you'll use https://download.eclipse.org/microprofile/microprofile-health-4.0/microprofile-health-spec-4.0.html[MicroProfile Health^] to report the health status of the microservice and PostgreSQL database connection.

Navigate to your application directory

ifndef::cloud-hosted[]
```
cd start/inventory
```
endif::[]

ifdef::cloud-hosted[]
```bash
cd /home/project/guide-liberty-deep-dive/start/inventory
```
endif::[]

A health report is generated automatically for all health services that enable MicroProfile Health.

All health services must provide an implementation of the `HealthCheck` interface, which is used to verify their health. MicroProfile Health offers health checks for startup, liveness, and readiness.

A startup check allows applications to define startup probes that are used for initial verification of the application before the liveness probe takes over. For example, a startup check might check which applications require additional startup time on their first initialization.

A liveness check allows third-party services to determine whether a microservice is running. If the liveness check fails, the application can be terminated. For example, a liveness check might fail if the application runs out of memory.

A readiness check allows third-party services, such as Kubernetes, to determine whether a microservice is ready to process requests.

Create the `health` subdirectory before creating the health check classes.

ifndef::cloud-hosted[]
[.tab_link.windows_link]
`*WINDOWS*`
[.tab_link.mac_link]
`*MAC*`
[.tab_link.linux_link]
`*LINUX*`

[.tab_content.windows_section]
--
[role='command']
```
mkdir src\main\java\io\openliberty\deepdive\rest\health
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
mkdir src/main/java/io/openliberty/deepdive/rest/health
```
--
endif::[]

ifdef::cloud-hosted[]
```bash
mkdir /home/project/guide-liberty-deep-dive/start/inventory/src/main/java/io/openliberty/deepdive/rest/health
```
endif::[]

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `StartupCheck` class.#
`src/main/java/io/openliberty/deepdive/rest/health/StartupCheck.java`
----

StartupCheck.java
[source, java, linenums, role='code_column tags=StartupCheck hide_tags=copyright']
----
include::finish/module-health-checks/src/main/java/io/openliberty/deepdive/rest/health/StartupCheck.java[]
----

The [hotspot=Startup file=0]`@Startup` annotation indicates that this class is a startup health check procedure. Navigate to the http://localhost:9080/health/started URL to check the status of the startup health check. In this case, you are checking the cpu usage. If more than 95% of the cpu is being used, a status of `DOWN` is returned.
ifdef::cloud-hosted[]
```bash
curl -s http://localhost:9080/health/started | jq
```
endif::[]

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `LivenessCheck` class.#
`src/main/java/io/openliberty/deepdive/rest/health/LivenessCheck.java`
----

LivenessCheck.java
[source, java, linenums, role='code_column tags=LivenessCheck hide_tags=copyright']
----
include::finish/module-health-checks/src/main/java/io/openliberty/deepdive/rest/health/LivenessCheck.java[]
----

The [hotspot=Liveness file=1]`@Liveness` annotation indicates that this class is a liveness health check procedure. Navigate to the http://localhost:9080/health/live URL to check the status of the liveness health check. In this case, you are checking the heap memory usage. If more than 90% of the maximum memory is being used, a status of `DOWN` is returned.

ifdef::cloud-hosted[]
```bash
curl -s http://localhost:9080/health/live | jq
```
endif::[]

[role="code_command hotspot file=2", subs="quotes"]
----
#Create the `ReadinessCheck` class.#
`src/main/java/io/openliberty/deepdive/rest/health/ReadinessCheck.java`
----

ReadinessCheck.java
[source, java, linenums, role='code_column tags=ReadinessCheck hide_tags=copyright']
----
include::finish/module-health-checks/src/main/java/io/openliberty/deepdive/rest/health/ReadinessCheck.java[]
----
The [hotspot=Readiness file=2]`@Readiness` annotation indicates that this class is a readiness health check procedure. Navigate to the http://localhost:9080/health/ready URL to check the status of the readiness health check. This readiness check tests the connection to the PostgreSQL container that was created earlier in the guide. If the connection is refused, a status of `DOWN` is returned.

ifdef::cloud-hosted[]
```bash
curl -s http://localhost:9080/health/ready | jq
```
endif::[]

Or, you can visit the http://localhost:9080/health URL to see the overall health status of the application.

ifdef::cloud-hosted[]
```bash
curl -s http://localhost:9080/health | jq
```
endif::[]

== Providing metrics

Next, you can learn how to use https://download.eclipse.org/microprofile/microprofile-metrics-4.0/microprofile-metrics-spec-4.0.html[MicroProfile Metrics^] to provide metrics from the `inventory` microservice.

Go to your application directory.

ifndef::cloud-hosted[]
```
cd start/inventory
```
endif::[]

ifdef::cloud-hosted[]
```bash
cd /home/project/guide-liberty-deep-dive/start/inventory
```
endif::[]

Enable the `bob` user to access the `/metrics` endpoints.

[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

// File 0
server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-metrics/src/main/liberty/config/server.xml[]
----

The [hotspot=administrator file=0]`administrator-role` configuration authorizes the `bob` user as an administrator.

Use annotations that are provided by MicroProfile Metrics to instrument the `inventory` microservice to provide application-level metrics data.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `SystemResource` class.#
`src/main/java/io/openliberty/deepdive/rest/SystemResource.java`
----

// File 1
SystemResource.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/module-metrics/src/main/java/io/openliberty/deepdive/rest/SystemResource.java[]
----

Import the [hotspot=metricsImport file=1]`Counted` annotation and apply it to the [hotspot=metricsAddSystem file=1]`POST /api/systems`, [hotspot=metricsUpdateSystem file=1]`PUT /api/systems/{hostname}`, [hotspot=metricsRemoveSystem file=1]`DELETE /api/systems/{hostname}`, and [hotspot=metricsAddSystemClient file=1]`POST /api/systems/client/{hostname}` endpoints to monotonically count how many times that the endpoints are accessed. 

Additional information about the annotations that MicroProfile metrics provides, relevant metadata fields, and more are available at the https://openliberty.io/docs/22.0.0.4/reference/javadoc/microprofile-5.0-javadoc.html?package=org/eclipse/microprofile/metrics/annotation/package-frame.html&class=overview-summary.html[MicroProfile Metrics Annotation Javadoc^].

ifndef::cloud-hosted[]
Point your browser to the http://localhost:9080/openapi/ui[^] URL to try out your application and call some of the endpoints that you annotated.
endif::[]

ifdef::cloud-hosted[]
Run the following commands to call some of the endpoints that you annotated:

```bash
curl -k --user bob:bobpwd -X DELETE \
  'https://localhost:9443/inventory/api/systems/localhost'
```

```bash
curl -X POST 'http://localhost:9080/inventory/api/systems?heapSize=1048576&hostname=localhost&javaVersion=9&osName=linux'
```

```bash
curl -k --user alice:alicepwd -X PUT \
  'http://localhost:9080/inventory/api/systems/localhost?heapSize=2097152&javaVersion=11&osName=linux'
```

```bash
curl -s 'http://localhost:9080/inventory/api/systems' | jq
```
endif::[]

MicroProfile Metrics provides 4 different REST endpoints.

* The `/metrics` endpoint provides you with all the metrics in text format. 
* The `/metrics/application` endpoint provides you with application-specific metrics.
* The `/metrics/base` endpoint provides you with metrics that are defined in MicroProfile specifications. Metrics in the base scope are intended to be portable between different MicroProfile-compatible runtimes.
* The `/metrics/vendor` endpoint provides you with metrics that are specific to the runtime.

ifndef::cloud-hosted[]
Point your browser to the https://localhost:9443/metrics[^] URL to review all the metrics that are enabled through MicroProfile Metrics. Log in with `bob` as your username and `bobpwd` as your password. You can see the metrics in text format.

To see only the application metrics, point your browser to https://localhost:9443/metrics/application[^]. You can expect to see your application metrics in the output.

[source, role="no_copy"]
----
# TYPE application_addSystemClient_total counter
# HELP application_addSystemClient_total Number of times adding a system by client is called
application_addSystemClient_total 0
# TYPE application_addSystem_total counter
# HELP application_addSystem_total Number of times adding system endpoint is called
application_addSystem_total 1
# TYPE application_updateSystem_total counter
# HELP application_updateSystem_total Number of times updating a system endpoint is called
application_updateSystem_total 1
# TYPE application_removeSystem_total counter
# HELP application_removeSystem_total Number of times removing a system endpoint is called
application_removeSystem_total 1
----

You can see the system metrics at the https://localhost:9443/metrics/base[^] URL. You can also see the vendor metrics at the https://localhost:9443/metrics/vendor[^] URL.
endif::[]

// cloud-hosted guide instructions:
ifdef::cloud-hosted[]
Run the following curl command to see the application metrics that are enabled through MicroProfile Metrics:
```bash
curl -k --user bob:bobpwd https://localhost:9443/metrics/application
```

You can expect to see your application metrics in text format as the following output:

```
# TYPE application_addSystemClient_total counter
# HELP application_addSystemClient_total Number of times adding a system by client is called
application_addSystemClient_total 0
# TYPE application_addSystem_total counter
# HELP application_addSystem_total Number of times adding system endpoint is called
application_addSystem_total 1
# TYPE application_updateSystem_total counter
# HELP application_updateSystem_total Number of times updating a system endpoint is called
application_updateSystem_total 1
# TYPE application_removeSystem_total counter
# HELP application_removeSystem_total Number of times removing a system endpoint is called
application_removeSystem_total 1
```

To see the system metrics, run the following curl command:
```bash
curl -k --user bob:bobpwd https://localhost:9443/metrics/base
```

To see the vendor metrics, run the following curl command:
```bash
curl -k --user bob:bobpwd https://localhost:9443/metrics/vendor
```

To review all the metrics, run the following curl command:
```bash
curl -k --user bob:bobpwd https://localhost:9443/metrics
```
endif::[]


== Building the container 

Press `CTRL+C` in the command-line session to stop the `gradlew libertyDev` dev mode that you started in the previous section.

Navigate to your application directory:

ifndef::cloud-hosted[]
```
cd start/inventory
```
endif::[]

ifdef::cloud-hosted[]
```bash
cd /home/project/guide-liberty-deep-dive/start/inventory
```
endif::[]

The first step to containerizing your application inside of a container is creating a Containerfile. A Containerfile is a collection of instructions for building a container image that can then be run as a container. 

Make sure to start your podman daemon before you proceed.

[role="code_command hotspot file=0",subs="quotes"]
----
#Replace the `Containerfile` in the `start/inventory` directory.#
`Containerfile`
----

Containerfile
[source, text, linenums, role="code_column"]
----
include::finish/module-kubernetes/Containerfile[]
----

The [hotspot=from file=0]`FROM` instruction initializes a new build stage and indicates the parent image from which your image is built. In this case, you’re using the `icr.io/appcafe/open-liberty:full-java11-openj9-ubi` image that comes with the latest Open Liberty runtime as your parent image.

To help you manage your images, you can label your container images with the [hotspot=label file=0]`LABEL` command. 

The [hotspot=copy file=0]`COPY` instructions are structured as `COPY` `[--chown=<user>:<group>]` `<source>` `<destination>`. They copy local files into the specified destination within your container  image. In this case, the first [hotspot=copy-config file=0]`COPY` instruction copies the server configuration file that is at `src/main/liberty/config/server.xml` to the `/config/` destination directory. Similarly, the second [hotspot=copy-war file=0]`COPY` instruction copies the `.war` file to the `/config/apps` destination directory.



=== Building the container image

Run the `war` task from the `start/inventory` directory so that the `.war` file resides in the `build/libs` directory.

ifdef::cloud-hosted[]
```bash
cd /home/project/guide-liberty-deep-dive/start/inventory
```
endif::[]

[role='command']
```
./gradlew war
```

Build your container image with the following commands:

[role='command']
```
podman build -t liberty-deepdive-inventory:1.0-SNAPSHOT .
```

ifdef::cloud-hosted[]
In this Skills Network environment, you need to push the image to your container registry on IBM Cloud by running the following commands:
```bash
docker tag liberty-deepdive-inventory:1.0-SNAPSHOT us.icr.io/$SN_ICR_NAMESPACE/liberty-deepdive-inventory:1.0-SNAPSHOT
docker push us.icr.io/$SN_ICR_NAMESPACE/liberty-deepdive-inventory:1.0-SNAPSHOT
```
endif::[]

When the build finishes, run the following command to list all local container images:
[role='command']
```
podman images
```

Verify that the `liberty-deepdive-inventory:1.0-SNAPSHOT` image is listed among the container images, for example:
[source, role="no_copy"]
----
REPOSITORY                             TAG
localhost/liberty-deepdive-inventory   1.0-SNAPSHOT
icr.io/appcafe/open-liberty            full-java11-openj9-ubi
----


=== Running the application in container

Now that the `inventory` container image is built, you will run the application in container:

[role='command']
```
podman run -d --name inventory -p 9080:9080 liberty-deepdive-inventory:1.0-SNAPSHOT
```

The following table describes the flags in this command: 

[cols="15, 100", options="header"]
|===
| *Flag* | *Description*
| -d     | Runs the container in the background.
| --name | Specifies a name for the container.
| -p     | Maps the host ports to the container ports. For example: `-p <HOST_PORT>:<CONTAINER_PORT>`
|===

Next, run the `podman ps` command to verify that your container is started:

[role='command']
```
podman ps
```

Make sure that your container is running and show `Up` as their status:

[role="no_copy"]
----
CONTAINER ID    IMAGE                                              COMMAND                CREATED          STATUS          PORTS                                        NAMES
2b584282e0f5    localhost/liberty-deepdive-inventory:1.0-SNAPSHOT  /opt/ol/wlp/bin/s...   8 seconds ago    Up 8 second     0.0.0.0:9080->9080/tcp   inventory
----

If a problem occurs and your container exit prematurely, the container don't appear in the container
list that the `podman ps` command displays. Instead, your container appear with an `Exited` status when you run the `podman ps -a` command. Run the `podman logs inventory` command to view the container logs for any potential problems. Run the `podman stats inventory` command to display a live stream of usage statistics for your container. You can also double-check that your `Containerfile` file is correct. When you find the cause of the issues, remove the faulty container with the `podman rm inventory` command. Rebuild your image, and start the container again.

Now, you can access the application by the http://localhost:9080/inventory/api/systems URL. Alternatively, for the updated OpenAPI UI, use the following URL http://localhost:9080/openapi/ui/.

When you’re finished trying out the application, run the following commands to stop the container:

[role='command']
```
podman stop inventory
podman rm inventory
```

To learn how to optimize the image size, check out the https://openliberty.io/guides/containerize-podman.html#optimizing-the-image-size[Containerizing microservices with Podman guide^].


== Support Licensing

Open Liberty is open source under the Eclipse Public License v1 so there is no fee to use it in production. Community support is available at StackOverflow, Gitter, or the mail list, and bugs can be raised in https://github.com/openliberty/open-liberty[GitHub^]. Commercial support is available for Open Liberty from IBM. For more information, see the https://www.ibm.com/uk-en/marketplace/elite-support-for-open-liberty[IBM Marketplace^]. The WebSphere Liberty product is built on Open Liberty. No migration is required to use WebSphere Liberty, you simply point to WebSphere Liberty in your build. WebSphere Liberty users get support for the packaged Open Liberty function.

WebSphere Liberty is also available in https://search.maven.org/search?q=g:com.ibm.websphere.appserver.runtime[Maven Central^].

You can use WebSphere Liberty for development even without purchasing it. However, if you have production entitlement, you can easily change to use it with the following steps.

In the `build.gradle`, add the `liberty` element as the following:

[role="no_copy"]
----
liberty {
    runtime = [ 'group':'com.ibm.websphere.appserver.runtime',
                'name':'wlp-kernel']
}
----

Rebuild and restart the `inventory` service by dev mode:

[role="no_copy"]
----
./gradlew clean
./gradlew libertyDev
----

In the `Containerfile`, replace the Liberty image at the `FROM` statement with `websphere-liberty` as shown in the following example:
[role="no_copy"]
----
FROM icr.io/appcafe/websphere-liberty:full-java11-openj9-ubi

ARG VERSION=1.0
ARG REVISION=SNAPSHOT
...
----

== Great work! You're done!

You just completed a hands-on deep dive on Liberty!

include::{common-includes}/attribution.adoc[]
